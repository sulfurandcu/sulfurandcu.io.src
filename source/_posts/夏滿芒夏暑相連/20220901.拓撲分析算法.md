---
title: 拓撲分析算法
id: clnyhr2mp002t10rqf5z089pu
date: 2022-09-01 23:19:02
tags: [拓撲識別, 拓撲分析]
categories: [開發筆記]
---

2022年09月01日於武漢

{% mermaid flowchart TB %}
%%{init: { "flowchart": { "curve": "basis" } } }%%
R0[智能融合終端<br>SCU]
R0--->N1[斷路器<br>9]
R0--->N2[斷路器<br>16]
N1--->N1.1[斷路器<br>7]
N1--->N1.2[斷路器<br>6]
N1--->N1.3[斷路器<br>10]
N1--->N1.4[斷路器<br>12]
N2--->N2.1[斷路器<br>18]
N2--->N2.2[斷路器<br>19]
N2--->N2.3[斷路器<br>14]
N1.1--->N1.1.1[斷路器<br>3]
N1.1--->N1.1.2[斷路器<br>4]
N1.1--->N1.1.3[斷路器<br>5]
N1.2--->N1.2.1[斷路器<br>8]
N1.2--->N1.2.2[斷路器<br>11]
N1.3--->N1.3.1[斷路器<br>2]
N2.2--->N2.2.1[斷路器<br>13]
N2.2--->N2.2.2[斷路器<br>17]
N1.1.1--->N1.1.1.1[斷路器<br>0]
N1.2.2--->N1.2.2.1[斷路器<br>1]
N2.2.2--->N2.2.2.1[斷路器<br>15]
{% endmermaid %}

<!-- more -->

## 拓撲識別

![圖片加載失敗](topology.standard.1.png)

![圖片加載失敗](topology.standard.2.png)

![圖片加載失敗](topology.standard.3.png)

{% note danger no-icon %}
本文所述的拓撲分析算法針對的是有時間戳的拓撲識別
{% endnote %}

## 拓撲流程

{% mermaid flowchart TB %}
%%{init: { "flowchart": { "curve": "basis" } } }%%
R0[智能融合終端<br>SCU]-->A2[" "]
R0-->A1[斷路器<br>1]
A1-->B2[" "]
A1-->B1[斷路器<br>2]
B1-->C2[" "]
B1-->C1[斷路器<br>3]
{% endmermaid %}

以上面這個簡單的拓撲結構爲例：

當 SCU 給一號斷路器發送拓撲信號發生指令後一號斷路器會存儲一條發生記錄。

當 SCU 給二號斷路器發送拓撲信號發生指令後二號斷路器會存儲一條發生記錄，此時一號斷路器會識別到拓撲信號並存儲一條識別記錄，並且這兩條記錄中的時間基本一致。

當 SCU 給三號斷路器發送拓撲信號發生指令後三號斷路器會存儲一條發生記錄，此時一號斷路器和二號斷路器均會識別到拓撲信號並存儲一條識別記錄，並且這三條記錄中的時間基本一致。

最終：
- 一號斷路器總計存儲 3 條拓撲記錄；
- 二號斷路器總計存儲 2 條拓撲記錄；
- 三號斷路器總計存儲 1 條拓撲記錄；

拓撲信號發生流程結束後，智能融合終端會讀取每臺斷路器中的拓撲記錄，並將數據整理爲以下格式：

![圖片加載失敗](topology.record.png)

然後智能融合終端便可通過本算法以及上述數據計算出所有斷路器之間的拓撲關係。

{% note info no-icon %}
記錄數量：每臺斷路器中拓撲記錄的數量
記錄內容：每條拓撲記錄產生時的時間戳
{% endnote %}

## 算法概述

**核心思想：從末端節點開始，依次尋找每個節點的父節點，最終找到根節點。最後遞歸打印出拓撲關係。**

1\. 遍歷只有一條記錄的節點（末端節點）遍歷完之後將末端節點的記錄數量置爲零。

2\. 遍歷其他大於一條記錄的節點

3\. 判斷該節點是否存在與末端節點時間相同的記錄｜如果存在則表示該節點爲末端節點的潛在父節點（並將該節點的記錄數量減一）

4\. 拓撲記錄數量最少的那個節點即爲當前末端節點的父節點

5\. 更新拓撲網絡（記錄父節點）

6\. 更新修改過的記錄數量｜然後開始下一循環｜直至所有記錄數量爲零爲止

7\. 最後可以得到每個節點的父節點是誰（父節點爲自身的即爲根節點，可以存在多個根節點）

8\. 將上述數據遞歸打印即可得到期望結果

## 算法詳解

這裏通過一個示例來描述該算法的邏輯。

### 遍歷之前的拓撲結構（示例）

{% mermaid flowchart TB %}
%%{init: { "flowchart": { "curve": "basis" } } }%%
R0[智能融合終端<br>SCU]
R0--->N1[斷路器<br>9]
R0--->N2[斷路器<br>16]
N1--->N1.1[斷路器<br>7]
N1--->N1.2[斷路器<br>6]
N1--->N1.3[斷路器<br>10]
N1--->N1.4[斷路器<br>12]
N2--->N2.1[斷路器<br>18]
N2--->N2.2[斷路器<br>19]
N2--->N2.3[斷路器<br>14]
N1.1--->N1.1.1[斷路器<br>3]
N1.1--->N1.1.2[斷路器<br>4]
N1.1--->N1.1.3[斷路器<br>5]
N1.2--->N1.2.1[斷路器<br>8]
N1.2--->N1.2.2[斷路器<br>11]
N1.3--->N1.3.1[斷路器<br>2]
N2.2--->N2.2.1[斷路器<br>13]
N2.2--->N2.2.2[斷路器<br>17]
N1.1.1--->N1.1.1.1[斷路器<br>0]
N1.2.2--->N1.2.2.1[斷路器<br>1]
N2.2.2--->N2.2.2.1[斷路器<br>15]
{% endmermaid %}

### 遍歷之前的數據結構（示例）

![圖片加載失敗](topology.result.0.svg)

### 第一次遍歷後的拓撲結構

{% mermaid flowchart TB %}
%%{init: { "flowchart": { "curve": "basis" } } }%%
R0[智能融合終端<br>SCU]
R0--->N1[斷路器<br>9]
R0--->N2[斷路器<br>16]
N1--->N1.1[斷路器<br>7]
N1--->N1.2[斷路器<br>6]
N1--->N1.3[斷路器<br>10]
N1--->N1.4[" "]
N2--->N2.1[" "]
N2--->N2.2[斷路器<br>19]
N2--->N2.3[" "]
N1.1--->N1.1.1[斷路器<br>3]
N1.1--->N1.1.2[" "]
N1.1--->N1.1.3[" "]
N1.2--->N1.2.1[" "]
N1.2--->N1.2.2[斷路器<br>11]
N1.3--->N1.3.1[" "]
N2.2--->N2.2.1[" "]
N2.2--->N2.2.2[斷路器<br>17]
N1.1.1--->N1.1.1.1[" "]
N1.2.2--->N1.2.2.1[" "]
N2.2.2--->N2.2.2.1[" "]
{% endmermaid %}

### 第一次遍歷後的數據結構

![圖片加載失敗](topology.result.1.svg)

### 第二次遍歷後的拓撲結構

{% mermaid flowchart TB %}
%%{init: { "flowchart": { "curve": "basis" } } }%%
R0[智能融合終端<br>SCU]
R0--->N1[斷路器<br>9]
R0--->N2[斷路器<br>16]
N1--->N1.1[斷路器<br>7]
N1--->N1.2[斷路器<br>6]
N1--->N1.3[" "]
N1--->N1.4[" "]
N2--->N2.1[" "]
N2--->N2.2[斷路器<br>19]
N2--->N2.3[" "]
N1.1--->N1.1.1[" "]
N1.1--->N1.1.2[" "]
N1.1--->N1.1.3[" "]
N1.2--->N1.2.1[" "]
N1.2--->N1.2.2[" "]
N2.2--->N2.2.1[" "]
N2.2--->N2.2.2[" "]
{% endmermaid %}

### 第二次遍歷後的數據結構

![圖片加載失敗](topology.result.2.svg)

### 第三次遍歷後的拓撲結構

{% mermaid flowchart TB %}
%%{init: { "flowchart": { "curve": "basis" } } }%%
R0[智能融合終端<br>SCU]
R0--->N1[斷路器<br>9]
R0--->N2[斷路器<br>16]
N1--->N1.1[" "]
N1--->N1.2[" "]
N1--->N1.3[" "]
N1--->N1.4[" "]
N2--->N2.1[" "]
N2--->N2.2[" "]
N2--->N2.3[" "]
{% endmermaid %}

### 第三次遍歷後的數據結構

![圖片加載失敗](topology.result.3.svg)

### 遍歷完成之後得到的數據

![圖片加載失敗](topology.result.x.png)

## 核心代碼

```
    // 計算拓撲關係
    while (HaveData && HaveDataOneRecord)
    {
        HaveData = false;
        HaveDataOneRecord = false;

        for (int idx = 0; idx < TOPO_NODE_NUM; ++idx)
        {
            unsigned int MinNum = 0xFFFFFFFF;
            unsigned int MinIdx = idx;

            if (TopoNum[idx] > 0)
            {
                HaveData = true;
            }

            if (TopoNum[idx] == 1) // 遍歷只有一條記錄的節點（末端節點）
            {
                HaveDataOneRecord = true;

                TopoNumMod[idx]--;

                for (int i = 0; i < TOPO_NODE_NUM; ++i)
                {
                    if (TopoNum[i] <= 1) // 遍歷其他大於一條記錄的節點
                    {
                        continue;
                    }

                    for (int n = 1; n <= TopoSrc[i][0]; ++n) // 判斷該節點是否存在與末端節點時間相同的記錄
                    {
                        if (TimeCompare(TopoSrc[idx][1], TopoSrc[i][n], TOPO_TIME_BIAS)) // 4example bias==3 (±3s)
                        {
                            // 如果存在則表示該節點爲末端節點的潛在父節點（並將該節點的記錄數量減一）
                            TopoNumMod[i]--;
                            if (TopoSrc[i][0] < MinNum)
                            {
                                MinNum = TopoSrc[i][0];
                                MinIdx = i; // 查找拓撲記錄數量最少的節點
                                break;
                            }
                        }
                    }
                }

                TopoNet[idx] = MinIdx; // 拓撲記錄數量最少的那個節點即爲當前末端節點的父節點
            }
        }

        // 經過上述步驟，拓撲記錄數量爲一的節點的記錄數量被清零，同時又重新生成了一批新的拓撲記錄數量爲一的節點。
        // 這裏更新中間變量，然後繼續上述步驟：遍歷新的只有一條記錄的節點（新的末端節點），直至遍歷完畢。
        memcpy(TopoNum, TopoNumMod, sizeof(TopoNum));
    }
```

## 遞歸打印

```
void TopoPrint(unsigned int root, unsigned int *node, int node_num) // *node : 節點關係（所有節點的父節點信息）
{
    static int depth = 1;

    FILE * fp;

    for (int i = 0; i < node_num; ++i)
    {
        if (node[i] == root)
        {
            fp = fopen(TOPO_FILE_PATH, "a+");

            // 根節點禁止遞歸
            if (i == root)
            {
                fclose(fp);
                continue;
            }

            printf("|---");

            for (int d = 0; d < depth; ++d)
            {
                #if (ENABLE_PRINT)
                printf("|---");
                #endif
                #if (ENABLE_PRINT_TO_FILE)
                fprintf(fp, "|---");
                #endif
            }

            // 打印序號
            #if (ENABLE_PRINT)
            printf("%-8d", i);
            printf(TOPO_ALIGN_STR);
            #endif
            #if (ENABLE_PRINT_TO_FILE)
            fprintf(fp, "%-8d", i);
            fprintf(fp, TOPO_ALIGN_STR);
            #endif

            // 打印地址
            for (int len = 0; len < 6; ++len)
            {
                #if (ENABLE_PRINT)
                printf("%02X", TopoDev[i][len]);
                #endif
                #if (ENABLE_PRINT_TO_FILE)
                fprintf(fp, "%02X", TopoDev[i][len]);
                #endif
            }

            // 打印換行
            #if (ENABLE_PRINT)
            printf("\r\n");
            #endif
            #if (ENABLE_PRINT_TO_FILE)
            fprintf(fp, "\n");
            #endif

            fclose(fp);

            // 遞歸調用
            depth++;
            TopoPrint(i, node, node_num);
            depth--;
        }
    }
}
```
